<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>3. Assert: RATT - Triply Documentation</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="mkdocs-1.4.3, mkdocs-gitbook-1.0.7" name="generator"/>
<link href="../../../images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<meta content="true" name="HandheldFriendly">
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<meta href="" rel="next">
<link href="../../../css/style.min.css" rel="stylesheet"/>
</meta></meta></head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div> <!-- end of book-search-input -->
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="../../.." target="_blank">Triply Documentation</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../../..">Home</a>
<li class="header">TriplyDB</li>
<li>
<a class="" href="../../../triply-db-getting-started">Getting started</a>
</li>
<li class="header">TriplyETL</li>
<li>
<a href="#">General</a>
<ul>
<li>
<a class="" href="../..">Overview</a>
</li>
<li>
<a class="" href="../../getting-started">Getting started</a>
</li>
<li>
<a class="" href="../../cli">Command Line Interface (CLI)</a>
</li>
<li>
<a class="" href="../../changelog">Changelog</a>
</li>
<li>
<a class="" href="../../maintenance">Maintenance</a>
</li>
</ul>
</li>
<li>
<a href="#">TriplyETL Approach</a>
<ul>
<li>
<a class="" href="../../extract">Extract</a>
</li>
</ul>
</li>
<li class="header">Yasgui</li>
<li>
<a class="" href="../../../yasgui">Introduction</a>
</li>
<li class="divider"></li>
<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>
<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</li></ul>
</nav>
</div> <!-- end of book-summary -->
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="."></a>
</h1>
</div> <!-- end of book-header -->
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<p>RATT assertions are a core set of TypeScript functions that assert linked data.</p>
<h1 id="overview">Overview</h1>
<p>The following assertion functions are available:</p>
<table>
<thead>
<tr>
<th>Assertion</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#iri">iri()</a></td>
<td>Create an IRI term.</td>
</tr>
<tr>
<td><a href="#iris">iris()</a></td>
<td>Creates multiple IRI terms.</td>
</tr>
<tr>
<td><a href="#literal">literal()</a></td>
<td>Creates a literal term.</td>
</tr>
<tr>
<td><a href="#literals">literals()</a></td>
<td>Creates multiple literal terms.</td>
</tr>
<tr>
<td><a href="#nestedpairs">nestedPairs()</a></td>
<td>Creates a nested node with multiple triples that use that node as their subject term.</td>
</tr>
<tr>
<td><a href="#objects">objects()</a></td>
<td>Asserts multiple triples that share the same subject and predicate terms.</td>
</tr>
<tr>
<td><a href="#pairs">pairs()</a></td>
<td>Asserts multiple triples that share the same subject term.</td>
</tr>
<tr>
<td><a href="#quad">quad()</a></td>
<td>Asserts a quadruple.</td>
</tr>
<tr>
<td><a href="#quads">quads()</a></td>
<td>Asserts multiple quadruples.</td>
</tr>
<tr>
<td><a href="#str">str()</a></td>
<td>Creates a static string.</td>
</tr>
<tr>
<td><a href="#triple">triple()</a></td>
<td>Asserts a triple.</td>
</tr>
<tr>
<td><a href="#triples">triples()</a></td>
<td>Asserts multiple triples.</td>
</tr>
</tbody>
</table>
<p>All RATT assertions can be imported from the RATT library in TriplyETL:</p>
<pre><code class="language-ts">import { iri, iris, literal, literals, nestedPairs, objects,
         pairs, quad, quads, triple, triples
       } from '@triplyetl/etl/ratt'
</code></pre>
<h1 id="function-iri-iri">Function <code>iri()</code> {#iri}</h1>
<p>Asserts an IRI term based on a key and an optional IRI prefix:</p>
<ul>
<li><code>iri(prefix:PrefixedToIri, content:Key|StaticString)</code></li>
<li><code>iri(content:Key|StaticString)</code></li>
</ul>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>prefix</code> A prefix that is declared with <a href="/docs/triply-etl/declare#declarePrefix">declarePrefix()</a>.</li>
<li><code>content</code> Either a key that contains a string value, or a static string. If the <code>prefix</code> is used, this content is placed after the prefix (sometimes referred to a the 'local name'). If the <code>prefix</code> parameter is not used, the content must specify the full IRI.</li>
</ul>
<h2 id="examples">Examples</h2>
<p>The following asserts an IRI based on a declared prefix (<code>prefix.ex</code>) and a key (<code>name</code>):</p>
<pre><code class="language-ts">triple(iri(prefix.ex, 'name'), a, owl.NamedIndividual),
</code></pre>
<p>The following asserts an IRI based on a declared prefix (<code>prefix.ex</code>) and a static string (see function <a href="#str">str()</a>):</p>
<pre><code class="language-ts">triple(iri(prefix.ex, str('bob')), a, owl.NamedIndividual),
</code></pre>
<p>The following asserts an IRI based on the value stored in key <code>'url'</code>. Notice that this value must encode a full absolute IRI.</p>
<pre><code class="language-ts">fromJson([{ 'url': 'https://example.com/bob' }]),
triple(iri('url'), a, owl.NamedIndividual),
</code></pre>
<h2 id="see-also">See also</h2>
<p>If the same IRI is used in multiple statements, repeating the same assertion multiple times may impose a maintenance burden. In such cases, it is possible to first add the IRI to the record using transformation function <a href="/docs/triply-etl/transform/ratt#addIri">addIri()</a>, and refer to that one IRI in multiple statements.</p>
<p>Use function <a href="#iris">iris()</a> to create multiple IRIs in one step.</p>
<h1 id="function-iris-iris">Function <code>iris()</code> {#iris}</h1>
<p>Asserts multiple IRIs, one for each entry in an array of strings:</p>
<ul>
<li><code>iris(prefix:PrefixedToIri, content:Key|Array&lt;StaticString&gt;)</code></li>
<li><code>iris(content:Key|Array&lt;StaticString&gt;)</code></li>
</ul>
<h2 id="parameters_1">Parameters</h2>
<ul>
<li><code>prefix</code> A prefix that is declared with <a href="/docs/triply-etl/declare#declarePrefix">declarePrefix()</a>.</li>
<li><code>content</code> Either a key that contains a array of string values, or an array of static strings. If the <code>prefix</code> is used, this content is placed after the prefix (sometimes referred to a the 'local name'). If the <code>prefix</code> parameter is not used, the content must specify the full IRI.</li>
</ul>
<h2 id="example">Example</h2>
<p>The following code snippet asserts one IRI for each entry in record key <code>'children'</code>:</p>
<pre><code class="language-ts">fromJson([{ parent: 'John', children: ['Joe', 'Jane'] }]),
triple(iri(prefix.id, 'parent'), sdo.children, iris(prefix.id, 'children')),
</code></pre>
<p>This makes the following linked data assertions:</p>
<pre><code class="language-turtle">id:John sdo:children id:Joe, id:Jane.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  john -- sdo:children --&gt; joe
  john -- sdo:children --&gt; jane

  john[id:John]:::data
  joe[id:Joe]:::data
  jane[id:Jane]:::data

  classDef data fill:yellow
</div>
<h1 id="function-literal-literal">Function <code>literal()</code> {#literal}</h1>
<p>Asserts a literal term:</p>
<ul>
<li><code>literal(lexicalForm, languageTagOrDatatype)</code></li>
</ul>
<h2 id="parameters_2">Parameters</h2>
<ul>
<li><code>lexicalForm</code> A static string (see function <a href="#str">str()</a>), or a key that contains a string value.</li>
<li><code>languageTagOrDatatype</code> A static language tag, or a static datatype IRI, or a key that contains either a language tag or a datatype IRI.</li>
</ul>
<h2 id="examples_1">Examples</h2>
<p>The following snippet asserts a language-tagged string:</p>
<pre><code class="language-ts">triple('city', sdo.name, literal('name', lang.nl)),
</code></pre>
<p>The following snippet asserts a typed literal:</p>
<pre><code class="language-ts">triple('city', vocab.population, literal('population', xsd.nonNegativeInteger)),
</code></pre>
<p>Notice that string literals can be asserted directly; the following two statements make the same assertion:</p>
<pre><code class="language-ts">triple('city', dct.identifier, literal('id', xsd.string)),
triple('city', dct.identifier, 'id'),
</code></pre>
<p>These assertions combined can result in the following linked data:</p>
<pre><code class="language-turtle">id:amsterdam
  sdo:name 'Amsterdam'@nl
  vocab:population '800000'^^xsd:nonNegativeInteger
  dct:identifier '0200'.
</code></pre>
<h2 id="see-also_1">See also</h2>
<p>If the same literal is used in multiple statements, repeating the same assertion multiple times can impose a maintenance burden. In such cases, it is possible to first add the literal to the record with transformation <a href="/docs/triply-etl/transform/ratt#addLiteral">addLiteral()</a>, and refer to that one literal in multiple statements.</p>
<p>Use assertion <a href="#literals">literals()</a> to create multiple literals in one step.</p>
<h1 id="function-literals-literals">Function <code>literals()</code> {#literals}</h1>
<p>Asserts multiple literals, one for each given lexical form:</p>
<pre><code>literals(lexicalForms, languageTagOrDatatype)
</code></pre>
<p>When the record contains a key that stores an array, it is possible to create one literal for each value in the array.</p>
<h2 id="parameters_3">Parameters</h2>
<ul>
<li><code>lexicalForms</code> A key that stores an array.</li>
<li><code>languageTagOrDatatype</code> A static language tag, or a static datatype IRI, or a key that stores a language tag or datatype IRI.</li>
</ul>
<h2 id="example-fruit-basket">Example: Fruit basket</h2>
<p>The following code snippet creates one literal for each value in the array that is stored in the <code>'contents'</code> key:</p>
<pre><code class="language-ts">fromJson([{ id: 123, contents: ['apple', 'pear', 'banana'] }]),
triple(iri(prefix.basket, 'id'), rdfs.member, literals('contents', lang.en)),
</code></pre>
<p>This makes the following linked data assertions:</p>
<pre><code class="language-turtle">basket:123 rdfs:member 'apple'@en, 'banana'@en, 'pear'@en.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  basket -- rdfs:member --&gt; apple
  basket -- rdfs:member --&gt; banana
  basket -- rdfs:member --&gt; pear

  apple["'apple'@en"]:::data
  banana["'banana'@en"]:::data
  basket[basket:123]:::data
  pear["'pear'@en"]:::data

  classDef data fill:yellow
</div>
<h2 id="example-names">Example: Names</h2>
<p>String literals can be asserted directly from a key that stores an array of strings.</p>
<p>The following code snippet asserts one string literal for each child:</p>
<pre><code class="language-ts">fromJson([{ parent: 'John', children: ['Joe', 'Jane'] }]),
triple(iri(prefix.id, 'parent'), sdo.children, 'children'),
</code></pre>
<p>This makes the following linked data assertions:</p>
<pre><code class="language-turtle">id:John sdo:children 'Jane', 'Joe'.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  john -- sdo:children --&gt; jane
  john -- sdo:children --&gt; joe

  jane['Jane']:::data
  joe['Joe']:::data
  john['John']:::data

  classDef data fill:yellow
</div>
<p>Notice that the same could have been achieved with an explicit datatype IRI:</p>
<pre><code class="language-ts">triple(iri(prefix.id, 'parent'), sdo.children, literals('children', xsd.string)),
</code></pre>
<h1 id="function-nestedpairs-nestedpairs">Function <code>nestedPairs()</code> {#nestedPairs}</h1>
<p>This function creates a nested node and makes multiple assertions about that node.</p>
<p>Since linked data is composed of triples, more complex n-ary information must often be asserted with one or more nested nodes. Such nested nodes can be given a name with assertion <a href="#iri">iri()</a> or transformation <a href="/docs/triply-etl/transform/ratt#addiri">addIri()</a>.</p>
<h2 id="parameters_4">Parameters</h2>
<ul>
<li><code>subject</code> A subject term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>predicate</code> A predicate term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>nestedNode</code> The nested node. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>pairs</code> One or more pairs that make assertions about the nested node. Every pair consists of a predicate term and an object term (in that order).</li>
</ul>
<h2 id="example-unit-of-measure">Example: Unit of measure</h2>
<p>The following example asserts a value together with a unit of measure. A well-known Skolem IRI or 'blank node' is used to attach the value and unit to:</p>
<pre><code class="language-ts">fromJson([{ id: '1', height: 15 }]),
addSkolemIri({
  prefix: prefix.skolem,
  key: '_height',
}),
nestedPairs(iri(prefix.product, 'id'), sdo.height, '_height',
  [qudt.unit, unit.CentiM],
  [rdf.value, 'height'],
),
</code></pre>
<p>This makes the following linked data assertions:</p>
<pre><code class="language-turtle">product:1
  sdo:height
    [ qudt:unit unit:CentiM;
      rdf:value 15 ].
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  product -- sdo:height --&gt; skolem
  skolem -- qudt:unit --&gt; centim
  skolem -- rdf:value --&gt; 15

  product[product:1]:::data
  skolem[_:1]:::data
  centim[unit:CentiM]:::model
  15:::data

  classDef data fill:yellow
  classDef model fill:lightblue
  classDef meta fill:sandybrown
</div>
<h2 id="example-geometry">Example: Geometry</h2>
<p>The following example asserts a GeoSPARQL geometry. The geometry is created
as a separate node.</p>
<pre><code class="language-ts">fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
nestedpairs(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id'),
  [a, geo.Geometry],
  [geo.asWKT, literal('geometry', geo.wktLiteral)],
),
</code></pre>
<p>This generates the following linked data, where a well-known Skolem IRI is used for the geometry 'blank node':</p>
<pre><code class="language-turtle">feature:1 geo:hasGeometry geometry:1.
geometry:1
  a geo:Geometry;
  geo:asWKT 'Point(1.1 2.2)'^^geo:wktLiteral.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  feature -- geo:hasGeometry --&gt; geometry
  geometry -- a --&gt; Geometry
  geometry -- geo:asWKT --&gt; wkt

  feature[feature:1]:::data
  geometry[geometry:1]:::data
  Geometry[geo:Geometry]:::model
  wkt["'Point(1.1 2.2)'^^geo:wktLiteral"]:::data

  classDef data fill:yellow
  classDef model fill:lightblue
  classDef meta fill:sandybrown
</div>
<p>Assertions that use <code>nestedpairs()</code> provide a shorter notation for the following sequence of assertions that uses functions <a href="#triple">triple()</a> and <a href="#pairs">pairs()</a>:</p>
<pre><code class="language-ts">fromJson([{ id: '1', geometry: 'Point(1.1 2.2)' }]),
triple(iri(prefix.feature, 'id'), geo.hasGeometry, iri(prefix.geometry, 'id')),
pairs(iri(prefix.geometry, 'id'),
  [a, geo.Geometry],
  [geo.asWKT, literal('geometry', geo.wktLiteral)],
),
</code></pre>
<h2 id="see-also_2">See also</h2>
<p>In some cases, it is inconvenient to come up with a naming scheme for intermediate nodes. In such cases, the following options are available:
- Use transformation <a href="/docs/triply-etl/transform/ratt#addhashediri">addHashedIri()</a> to create a content-based IRI.
- Use transformation <a href="/docs/triply-etl/transform/ratt#addrandomiri">addRandomIri()</a> to create a random IRI.
- Use transformation <a href="/docs/triply-etl/transform/ratt#addskolemiri">addSkolemIri()</a> to create a random Skolem IRI.</p>
<h1 id="function-objects-objects">Function <code>objects()</code> {#objects}</h1>
<p>Asserts multiple triples that share the same subject term and predicate term.</p>
<p>This function provides a shorthand notation for assertions that can also be made with multiple uses of the <a href="#triple">triple()</a> assertion function. The notational convenience of this middleware is similar to predicate-object lists in TriG, Turtle, and SPARQL.</p>
<h2 id="parameters_5">Parameters</h2>
<ul>
<li><code>subject</code> A subject term. This must be either an IRI (see function <a href="#iri">iri()</a>) or a literal (see function <a href="#literal">literal()</a>).</li>
<li><code>predicate</code> A predicate term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>objects</code> An array of object terms. This must be either an IRI (see function <a href="#iri">iri()</a>) or a literal (see function <a href="#literal">literal</a>). Every distinct object term in the array results in a distinct triple assertion.</li>
</ul>
<h2 id="example-alternative-labels">Example: Alternative labels</h2>
<p>The following snippet asserts multiple alternative labels for a city:</p>
<pre><code class="language-ts">fromJson([{
   name: 'Ney York',
   alt1: 'The Big Apple',
   alt2: 'The Capital of the World',
   alt3: 'The City of Dreams',
   alt4:  'The City That Never Sleeps',
}]),
objects(iri(prefix.city, 'name'), skos.altLabel,
  ['alt1', 'alt2', 'alt3', 'alt4']
),
</code></pre>
<p>This results in the following 4 linked data assertions:</p>
<pre><code class="language-turtle">city:New%20York
  skos:altLabel
    'The Big Apple'@en.
    'The Capital of the World'@en,
    'The City of Dreams'@en,
    'The City That Never Sleeps'@en.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  newYork -- skos:altLabel --&gt; a &amp; b &amp; c &amp; d

  newYork[city:New%20York]:::data
  a["'The Big Apple'@en"]:::data
  b["'The Capital of the World'@en"]:::data
  c["'The City of Dreams'@en"]:::data
  d["'The City That Never Sleeps'@en"]:::data

  classDef data fill:yellow
</div>
<h1 id="function-pairs-pairs">Function <code>pairs()</code> {#pairs}</h1>
<p>Asserts multiple triples that share the same subject term.</p>
<p>This function provides a shorthand notation for assertions that can also be made with multiple uses of assertion <a href="#triple">triple()</a>. The notational convenience of this middleware is similar to predicate lists in TriG, Turtle, and SPARQL.</p>
<h2 id="parameters_6">Parameters</h2>
<ul>
<li><code>subject</code> The subject term of the asserted triples.</li>
<li><code>pairs</code> Zero or more pairs. Each pair is an array with a predicate term and an object term (in that order). Every distinct element in the <code>pairs</code> array results in a distinct triple assertion.</li>
</ul>
<h2 id="example-alternative-and-preferred-label">Example: Alternative and preferred label</h2>
<p>The following snippet asserts a preferred label and an alternative label for cities:</p>
<pre><code class="language-ts">fromJson([
  { name: 'London', alt: 'Home of the Big Ben' },
  { name: 'Ney York', alt: 'The Big Apple' },
]),
pairs(iri(prefix.city, 'name'),
  [skos.prefLabel, literal('name', lang.en)],
  [skos.altLabel, literal('alt', lang.en)],
),
</code></pre>
<p>This results in the following 4 linked data assertions:</p>
<pre><code class="language-turtle">city:London
  skos:prefLabel 'London'@en;
  skos:altLabel 'Home of the Big Ben'@en.
city:New%20York
  skos:prefLabel 'New York'@en;
  skos:altLabel 'The Big Apple'@en.
</code></pre>
<p>Or diagrammatically:</p>
<div class="mermaid">graph LR
  london -- skos:altLabel --&gt; a
  london -- skos:prefLabel --&gt; b
  newYork -- skos:altLabel --&gt; c
  newYork -- skos:prefLabel --&gt; d

  london[city:London]:::data
  newYork[city:New%20York]:::data
  a["'Home of the Big Ben'@en"]:::data
  b["'London'@en"]:::data
  c["'The Big Apple'@en"]:::data
  d["'New York'@en"]:::data

  classDef data fill:yellow
</div>
<h1 id="function-quad-quad">Function <code>quad()</code> {#quad}</h1>
<p>Asserts a quadruple or 'quad', i.e. a statement that consists of a subject term, a predicate term, an object term, and a graph name.</p>
<p>A quadruple is a triple with a graph name as its fourth parameter.</p>
<h2 id="parameters_7">Parameters</h2>
<ul>
<li><code>subject</code> A subject term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>predicate</code> A predicate term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>object</code> An object term. This must be either an IRI (see function <a href="#iri">iri()</a>) or a literal (see function <a href="#literal">literal()</a>).</li>
<li><code>graph</code> A graph name. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
</ul>
<h2 id="example-data-and-metadata">Example: Data and metadata</h2>
<p>An ETL may distinguish between data and metadata assertions. Both may be
placed into distinct graphs. The following snippet makes one assertion in
a metadata graph and one assertion in a data graph.</p>
<pre><code class="language-ts">quad(iri(prefix.dataset, 'flowers'), a, dcat.Dataset, graph.metadata),
quad(iri(prefix.flower, '_id'), a, def.Flower, graph.data),
</code></pre>
<h2 id="see-also_3">See also</h2>
<p>Use function <a href="#quads">quads()</a> to make multiple quadruple assertions.</p>
<h1 id="function-quads-quads">Function <code>quads()</code> {#quads}</h1>
<p>Asserts multiple quadruples or 'quads', i.e. statements that consists of a subject term, a predicate term, an object term, and a graph name.</p>
<p>A quadruple is a triple with a graph name as its fourth parameter.</p>
<h2 id="parameters_8">Parameters</h2>
<ul>
<li><code>subject</code> A subject term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>predicate</code> A predicate term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>object</code> An object term. This must be either an IRI (see function <a href="#iri">iri()</a>) or a literal (see function <a href="#literal">literal()</a>).</li>
<li><code>graph</code> A graph name. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
</ul>
<h2 id="example-data-and-metadata_1">Example: Data and metadata</h2>
<p>An ETL can distinguish between data and metadata assertions. Both may be
placed into distinct graphs. The following snippet makes assertions in a
metadata graph and assertions in a data graph.</p>
<pre><code class="language-ts">quads(
  [iri(prefix.dataset, 'flowers'), a, dcat.Dataset, graph.metadata],
  ...,
),
quads(
  [iri(prefix.flower, '_id'), a, def.Flower, graph.data],
  ...,
),
</code></pre>
<h2 id="see-also_4">See also</h2>
<p>Use function <a href="#quad">quad()</a> for asserting a single quadruple.</p>
<h1 id="function-str-str">Function <code>str()</code> {#str}</h1>
<p>Asserts a static string value.</p>
<h2 id="when-to-use">When to use</h2>
<p>Strings in assertions are typically used to denote keys in the Record. For example, the string <code>'abc'</code> in the following code snippet indicates that the value of key <code>'abc'</code> should be used as the local name of the IRI in the subject position. The value of key <code>'abc'</code> should also be used as the lexical form of the literal in the object position:</p>
<pre><code class="language-ts">triple(iri(prefix.id, 'abc'), rdfs.label, 'abc'),
</code></pre>
<p>But sometimes we want to assert a static string, i.e. the actual string value <code>'abc'</code> instead of the string value stored in a key with that name. In such cases the string function <code>str()</code> can be used.</p>
<p>The following code snippet asserts the IRI <code>id:abc</code> and literal <code>'abc'</code>:</p>
<pre><code class="language-ts">triple(iri(prefix.id, str('abc')), rdfs.label, str('abc')),
</code></pre>
<h1 id="function-triple-triple">Function <code>triple()</code> {#triple}</h1>
<p>Asserts a triple, i.e. a statement that consists of a subject term, a predicate term, and an object term.</p>
<p>A triple is a sequence of three terms: subject, predicate, and object. A triple asserts a factual statement, claiming that the thing denoted by the subject term and the thing denotes by the object term are related to one another according to the relationship denoted by the predicate term. A triple is the smallest unit of meaning in linked data.</p>
<h2 id="parameters_9">Parameters</h2>
<ul>
<li><code>subject</code> A subject term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>predicate</code> A predicate term. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>object</code> An object term. This must be either an IRI (see function <a href="#iri">iri()</a>) or a literal (see function <a href="#literal">literal()</a>).</li>
</ul>
<h2 id="example-1">Example 1</h2>
<p>The following triple asserts that something is a person. Notice that:
- the subject term is an IRI that is constructed out of an IRI prefix (<code>prefix.person</code>) and a key that contains the IRI local name (<code>'id'</code>),
- and the predicate and object terms are IRIs that are imported from the vocabulary module.</p>
<pre><code class="language-ts">triple(iri(prefix.person, 'id'), a, foaf.Person),
</code></pre>
<h2 id="example-2">Example 2</h2>
<p>The following triple asserts that something has an age that is derived from the <code>'age'</code> key in the record. Notice that:</p>
<ul>
<li>the subject term is an IRI that is stored in the <code>'_person'</code> key of the record (possibly created with transformation function <a href="#addiri">addIri()</a>),</li>
<li>the predicate term is an IRI (<code>foaf.age</code>) that is imported from the vocabulary module,</li>
<li>and the object term is a typed literal with a datatype IRI that is imported from the vocabulary module.</li>
</ul>
<pre><code class="language-ts">triple('_person', foaf.age, literal('age', xsd.nonNegativeInteger)),
</code></pre>
<h1 id="function-triples-triples">Function <code>triples()</code> {#triples}</h1>
<p>Asserts multiple triples in the same named graph:</p>
<ul>
<li><code>triples(graph, triples)</code></li>
</ul>
<h2 id="parameters_10">Parameters</h2>
<ul>
<li><code>graph</code> A graph name. This must be an IRI (see function <a href="#iri">iri()</a>).</li>
<li><code>triples</code> An array of triples. Every triple is represented by an array of 3 terms: subject, predicate, and object.</li>
</ul>
<h2 id="when-to-use_1">When to use</h2>
<p>It is common for multiple statements to occur in the same graph. In such cases, it is suboptimal to repeat the graph name for multiple uses of the <a href="#quad">quad()</a> function. In such cases, it is shorter to use the <code>triples()</code> function, where the graph name only needs to be specified once.</p>
<h2 id="example_1">Example</h2>
<p>Suppose that we want to distinguish between data and metadata assertions. We can do so by asserting them in distinct graphs. The following makes multiple metadata assertions in the metadata graph, followed by multiple data assertions in the data graph.</p>
<pre><code class="language-ts">triples(graph.metadata,
  [iri(prefix.dataset, str('flowers')), a, dcat.Dataset],
  ...
),
triples(graph.data,
  [iri(prefix.flower, '_id'), a, def.Flower],
  ...
),
</code></pre>
<h2 id="see-also_5">See also</h2>
<p>The <code>triples()</code> function is conceptually similar to graph notation in the TriG standard. In TriG, the graph name is specified up front, and the triples within that graph are specified immediately afterwards:</p>
<pre><code class="language-trig">graph:flowers {
  id:123 a def:Flower.
  # other triples go here
}
</code></pre>
<p>Notice the correspondence with the following code snippet that uses the <code>triples()</code> function:</p>
<pre><code class="language-ts">triples(iri(prefix.ex, 'myGraph'),
  [iri(prefix.ex, 'id'), a, def.Flower)],
  // other triples go here
),
</code></pre>
</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div> <!-- end of has-results -->
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->
</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->
</div> <!-- end of body-inner -->
</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</div><script src="https://unpkg.com/mermaid@8.8.0/dist/mermaid.min.js"></script><script>mermaid.initialize({});</script></body>
</html>