<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Create dynamic statements - Triply Documentation</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.4.3, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="../../.." target="_blank" class="custom-link">Triply Documentation</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../../..">Home</a>
<li class="header">TriplyDB</li>

<li>
<a href="../../../triply-db-getting-started" class="">Getting started</a>
</li>

<li class="header">TriplyETL</li>

<li>
<a href="#">General</a>
<ul>

<li>
<a href="../.." class="">Overview</a>
</li>

<li>
<a href="../../getting-started" class="">Getting started</a>
</li>

<li>
<a href="../../cli" class="">Command Line Interface (CLI)</a>
</li>

<li>
<a href="../../changelog" class="">Changelog</a>
</li>

<li>
<a href="../../maintenance" class="">Maintenance</a>
</li>
</ul>
</li>

<li>
<a href="#">TriplyETL Approach</a>
<ul>

<li>
<a href="../../extract" class="">Extract</a>
</li>
</ul>
</li>

<li class="header">Yasgui</li>

<li>
<a href="../../../yasgui" class="">Introduction</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="create-dynamic-statements">Create dynamic statements</h1>
<p>Dynamic statements are statements that are based on some aspect of the source data.</p>
<p>We use the following Record as an example:</p>
<table>
<thead>
<tr>
<th>Country</th>
<th>Inhabitants</th>
</tr>
</thead>
<tbody>
<tr>
<td>France</td>
<td>null</td>
</tr>
<tr>
<td>Germany</td>
<td>83190556</td>
</tr>
<tr>
<td>Netherlands</td>
<td>17650200</td>
</tr>
</tbody>
</table>
<p>We start with creating the prefix and term declarations (see the <a href="/docs/triply-etl/declare">Declare</a> documentation for more information):</p>
<pre><code class="language-ts">const base = declarePrefix('https://triplydb.com/Triply/example/')
const prefix = {
  def: declarePrefix(base('def/')),
  id: declarePrefix(base('id/')),
  xsd: declarePrefix('http://www.w3.org/2001/XMLSchema#'),
}

const def = {
  Country: prefix.def('Country'),
  name: prefix.def('inhabitants'),
}

const xsd = {
  positiveInteger: prefix.xsd('positiveInteger'),
  string: prefix.xsd('string'),
}


const input_string  = ['Country', 'inhabitants']
</code></pre>
<p>With these prefix and term constants in place, a dynamic statement is created as follows:</p>
<pre><code class="language-ts">triple(
  iri(prefix.id, 'Country'),
  def.inhabitants,
  literal('Inhabitants', xsd.positiveInteger)
),
</code></pre>
<p>Notice the following details:
- <code>iri()</code> is used to create a dynamic IRI term.
- Arguments <code>Country</code> and <code>Inhabitants</code> allow values for these keys to be used from processed Records.
- The IRI prefix for the subject term is specified with constant <code>prefix.id</code>.
- <code>literal</code> is used to create a dynamic literal term.
- For literals a datatype IRI can be specified.  If no datatype IRI is specified then the default IRI is <code>xsd.string</code>.</p>
<p><code>iri.hashed</code>can be used instead of <code>iri</code> when the ETL has a high number of blank nodes and they need more than one constant as input to hash a unique IRI.</p>
<pre><code class="language-ts">app.use(
  triple(
    iri.hashed(prefix.id, input_string),
    def.inhabitants,
    mw.toLiteral('Inhabitants', {datatype: xsd.positiveInteger})),
)
</code></pre>
<p>Notice the following details:
- <code>input_string</code> can pass more than one constant to hash a unique IRI term.</p>
<h1 id="static-and-dynamic-triples">Static and dynamic triples</h1>
<p>Be aware that there are different approaches forstatic<em> anddynamic</em> IRIs:</p>
<ul>
<li>Static IRIs are created with prefix declarations (example [1a]).</li>
<li>Dynamic IRIs are created with <code>iri()</code>,<code>iri.hashed</code> and prefix declarations (example [2a]).</li>
</ul>
<pre><code class="language-ts">[1a] prefix.id('person')
[2a] iri(prefix.id, 'person'),
[3a] iri.hashed(prefix.id, ['person','age']),

</code></pre>
<p>Notation [1a] creates thestatic* IRI [1b].  This IRI does not depend on the currently processed record.</p>
<p>Notation [2a] creates thedynamic* IRI in [2b], assuming the <code>"person"</code> key contains the value <code>"John"</code>.  This IRI depends on the currently processed record.</p>
<p>For a different record, IRI [2c] may be created instead (assuming the <code>"person"</code> key contains the value <code>"Jane"</code>).</p>
<p>Notation [3a] creates thedynamic* IRI in [3b], assuming the <code>"person"</code> key contains the value <code>"Sam"</code> and the
<code>"age"</code> key contains the value <code>"30"</code>. For a different record, IRI [3c] may be created instead (assuming the <code>"person"</code> key contains the value <code>"Roland"</code> and <code>"age"</code> key contains the value <code>"20"</code>).</p>
<pre><code class="language-turtle">[1b] id:person
[2b] id:John
[2c] id:Jane
[3b] id:Sam , age: 30
[3c] id:Sam , age: 20
</code></pre>
<p>--&gt;</p>
<h1 id="when-should-you-use-an-iri-instead-of-an-uri-literal">When should you use an IRI instead of an URI literal?</h1>
<p>An IRI is used to identify something, for example the city of Amsterdam. It is expected that accessing it returns linked data. An IRI can be used to make assertions about a subject. On the other hand, a URI is expected to return a non-linked data content, for example an HTML website, and can be used as objects in linked data, for example for inserting further information about the subject resource.
In the example below, the subject IRI is described further by the object's URL.</p>
<pre><code class="language-sh">&lt;https://dbpedia.org/resource/Amsterdam&gt; rdfs:seeAlso &quot;https://www.iamsterdam.com&quot;^^xsd:anyURI.
</code></pre>
<p>An IRI can be created with <code>iri()</code>, while an URI is created by using <code>literal()</code>.</p>
<h1 id="limitation-of-literal-and-iri">Limitation of <code>literal()</code> and <code>iri()</code></h1>
<p>There is a limitation for both <code>literal()</code> and <code>iri()</code>.  It is not possible to change the value in the record in the <code>literal()</code> and <code>iri()</code> assertions.  The value that is at that moment stored in the record for that key, is then added as either an IRI when called with the <code>iri()</code> function or as a literal when called with the function <code>literal()</code>.</p>
<p>The limitation is shown in the example below.  In the example we want to round the inhabitants number to the nearest thousand. We can not transform this in the <code>literal()</code> function.  Instead we need to add a <code>custom.change()</code> middleware which will execute the transformation.</p>
<pre><code class="language-ts">custom.change({
  key: 'Inhabitants',
  type: 'number',
  change: value =&gt; value / 1_000,
}),
triple(
  iri(prefix.id, 'Country'),
  def.name,
  literal('Inhabitants', xsd.positiveInteger)
),
</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</body>
</html>