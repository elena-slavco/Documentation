<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Getting started - Triply Documentation</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.4.3, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="../../.." target="_blank" class="custom-link">Triply Documentation</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../../..">Home</a>
<li class="header">TriplyDB</li>

<li>
<a href="../../../triply-db-getting-started" class="">Getting started</a>
</li>

<li class="header">TriplyETL</li>

<li>
<a href="#">General</a>
<ul>

<li>
<a href="../.." class="">Overview</a>
</li>

<li>
<a href="../../getting-started" class="">Getting started</a>
</li>

<li>
<a href="../../cli" class="">Command Line Interface (CLI)</a>
</li>

<li>
<a href="../../changelog" class="">Changelog</a>
</li>

<li>
<a href="../../maintenance" class="">Maintenance</a>
</li>
</ul>
</li>

<li>
<a href="#">TriplyETL Approach</a>
<ul>

<li>
<a href="../../extract" class="">Extract</a>
</li>
</ul>
</li>

<li class="header">Yasgui</li>

<li>
<a href="../../../yasgui" class="">Introduction</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h2 id="transforming-rdf-data">Transforming RDF data</h2>
<p>If you have RDF data that does not need to be transformed, see <a href="https://triply.cc/docs/ratt-working-with-ratt#direct-copying-of-source-data-to-destination">copying source data</a>.
If you have RDF data that <em>does</em> need to be transformed, you can use the following pattern. This example renames the graph.</p>
<pre><code class="language-ts">const etl = new Etl({ defaultGraph: graph.model })
etl.use(
  loadRdf(Source.file(`data/shapes.trig`)),
  mapQuads(
    (quad, ctx) =&gt; ctx.store.quad(
      quad.subject,
      quad.predicate,
      quad.object,
      iri(prefix.graph, 'new-graph')
    )
  ),
  toRdf(Destination.TriplyDb.rdf('my-dataset', remoteOptions))
)
</code></pre>
<p>Similarly, you can change all the subject, predicates or objects in your data.</p>
<p>Also, you can choose to transform triples of a specific subject, predicate, object or graph name. in this case, you should use:</p>
<pre><code class="language-ts">mapQuads(
  (quad, ctx) =&gt; ctx.store.quad(
    quad.subject,
    app.prefix.example('new-predicate'),
    quad.object,
    quad.graph
  ),
  {predicate: app.prefix.example(&quot;old-predicate&quot;)}
)
</code></pre>
<h2 id="connect-a-data-source">Connect a data source</h2>
<p>This section extends the pipeline from <a href="#publish-to-triplydb">the previous section</a> by connecting a data source.  TriplyETL can connect to database systems and web APIs, but to keep things simple we will use the following tabular input data from a local file:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
</tr>
</thead>
<tbody>
<tr>
<td>00001</td>
<td>Anna</td>
</tr>
<tr>
<td>00002</td>
<td>Bob</td>
</tr>
<tr>
<td>00003</td>
<td>Carol</td>
</tr>
</tbody>
</table>
<p>We then perform the following steps to build a pipelines that processes this data source:</p>
<ol>
<li>Create a text file called <code>example.csv</code> in a text editor, and copy/paste the following source data into that file:</li>
</ol>
<p><code>csv
   ID,NAME
   00001,Anna
   00002,Bob
   00003,Carol</code></p>
<ol>
<li>Open text file <code>main.ts</code> and add the following content:</li>
</ol>
<p>```ts
   import { Etl, declarePrefix, fromCsv, iri, literal, rdfs,
            Source, toRdf, triple } from '@triplyetl/etl/generic'
   import { rdfs } from '@triplyetl/etl/vocab'</p>
<p>export default async function (): Promise<Etl> {
     const etl = new Etl({
       prefixes: {
         ex: declarePrefix('https://example.com/'),
       },
     })
     etl.use(
       // Connects the tabular source data to the pipeline.
       // Every row in the table is processed as a TriplyETL record.
       fromCsv(Source.file('example.csv')),
       // Create a linked data statement that is based on the
             // source data.
       triple(iri(etl.prefix.ex, 'ID'), rdfs.label, 'NAME'),
       toRdf(Destination.file('example.ttl'))
     )
     return etl
   }
   ```</p>
<!--
// Create a universally unique identifier (IRI) based
// on the value in the 'ID' column and the declared
// 'person' prefix.

// Create a string literal based on the value in the
// 'NAME' column.
-->

<ol>
<li>Transpile the code with:</li>
</ol>
<p><code>sh
   npm run build</code></p>
<ol>
<li>Run the ETL with:</li>
</ol>
<p><code>sh
   npx etl</code></p>
<p>The TriplyETL script will give you a link to the uploaded dataset.  This dataset contains the following graph content:</p>
<p><img alt="" src="connect-a-data-source.png" /></p>
<h2 id="important-terms-before-starting-to-work-with-triplyetl">Important terms before starting to work with TriplyETL</h2>
<h3 id="middlewares">Middlewares</h3>
<p>The most common occurrence in ETL are the middlewares. Middlewares are essentially reusable pieces of code that execute a certain long and/or complex piece of functionality. An middleware is a piece of code that transforms a record and can be invoked with app.use().</p>
<p>Example of middleware function:</p>
<pre><code class="language-ts">loadRdf(Source.TriplyDb.query('my-account', 'my-query')),
</code></pre>
<h3 id="what-is-a-record">What is a record?</h3>
<p>TriplyETL doesn't have infinite memory and not all data can be loaded at once. So instead of loading data all at once, first one part of data is processed and written to the file, and then the second one, third one, and so on. These parts are called records. Each record goes through all middlewares before a new record is started.</p>
<h3 id="what-is-the-store">What is the store?</h3>
<p>As mentioned above, when ETL is running we go through data record by record. Together with the input data we also have output data. Before being written to the final destination (triplyDB or file), output data has to be kept somewhere and that's what store  is for. The store is for temporarily storing linked data. Every record has its own store.
toRdf reads from the store.</p>
<pre><code class="language-ts">etl.use(
  toRdf(Ratt.Destination.file('example.ttl'))
)
</code></pre>
<h3 id="what-is-the-contextctx">What is the context(ctx)?</h3>
<p>In TriplyETL, the context is an object that represents the current record. The context gives us access to the triple store, the in memory storage of our triples. It also contains utility functions that will be used to modify and transform our source data into linked data. Some examples of ctx:</p>
<pre><code class="language-ts">ctx.getString(&quot;address&quot;)
ctx.getIri(...)
ctx.getArray(...)
ctx.store.addQuad(...)
ctx.store.getQuad(...)
//etc.
</code></pre>
<h2 id="a-json-data-source">A JSON data source</h2>
<p>The following code snippet uses extractor <a href="#fromJson">fromJson()</a> with two inline example records:</p>
<pre><code class="language-ts">import { fromJson, logRecord, Etl } from '@triplydb/etl/generic'
export default async function (): Promise&lt;Etl&gt; {
  const etl = new Etl()
  etl.use(
    fromJson([
      { id: '123', name: 'John' },
      { id: '456', name: 'Jane' },
    ]),
    logRecord(),
  )
  return etl
}
</code></pre>
<p>Debug function <code>logRecord()</code> prints the current record to standard output.  When this pipeline is run, the two records are printed as follows:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;123&quot;,
  &quot;name&quot;: &quot;John&quot;,
  &quot;$recordId&quot;: 1,
  &quot;$environment&quot;: &quot;Development&quot;
}
{
  &quot;id&quot;: &quot;456&quot;,
  &quot;name&quot;: &quot;Jane&quot;,
  &quot;$recordId&quot;: 2,
  &quot;$environment&quot;: &quot;Development&quot;
}
</code></pre>
<p>Notice that TriplyETL adds two keys to both records: <code>$recordId</code> and <code>$environment</code> (see <a href="#special-keys">Special Key</a>).</p>
<h2 id="an-xml-data-source">An XML data source</h2>
<p>Now suppose that we change the source system.  We no longer use in-line JSON, but will instead use an XML file.  The contents of the XML file are as follows:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;persons&gt;
  &lt;person&gt;
    &lt;id&gt;123&lt;/id&gt;
    &lt;name&gt;John&lt;/name&gt;
  &lt;/person&gt;
  &lt;person&gt;
    &lt;id&gt;456&lt;/id&gt;
    &lt;name&gt;Jane&lt;/name&gt;
  &lt;/person&gt;
&lt;/persons&gt;
</code></pre>
<p>Let us change the TriplyETL script to use the XML source connector:</p>
<pre><code class="language-ts">import { Etl, fromXml, logRecord, Source } from '@triplyetl/etl/generic'
export default async function (): Promise&lt;Etl&gt; {
  const etl = new Etl()
  etl.use(
    fromXml(Source.file('example.xml')),
    logRecord(),
  )
  return etl
}
</code></pre>
<p>This new script logs the following two records:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;123&quot;,
  &quot;name&quot;: &quot;John&quot;,
  &quot;$recordId&quot;: 1,
  &quot;$environment&quot;: &quot;Development&quot;
}
{
  &quot;id&quot;: &quot;456&quot;,
  &quot;name&quot;: &quot;Jane&quot;,
  &quot;$recordId&quot;: 2,
  &quot;$environment&quot;: &quot;Development&quot;
}
</code></pre>
<p>Notice that the two records that are logged from an XML source are completely identical to the two records that were previously logged from a JSON source.  This is an essential property of TriplyETL: it treats data from any source system in the same way, using the same intermediary record format.  This makes it easy to write pipelines that process data from a large number of different data sources.  This also makes replacing a data source in one format with a data source in another format a relatively cheap operation.  More often than not, only the source connector needs to be changed, and all transformations and assertions remain as they were.</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</body>
</html>